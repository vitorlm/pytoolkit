import os
from typing import Any

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from utils.logging.logging_manager import LogManager


class ChartMixin:
    """Generic mixin for generating charts. It does not know anything about domain-specific data
    (e.g., criteria). It expects that the caller provides the data in the expected format.
    """

    _logger = None  # Can be overridden in subclasses

    @property
    def logger(self):
        """Returns the logger. If `_logger` is defined in the instance (or subclass),
        that logger is used. Otherwise, a default logger is created.
        """
        if self._logger is None:
            self._logger = LogManager.get_instance().get_logger("ChartMixin")
        return self._logger

    def _save_plot(
        self,
        plt_instance: Any,
        filename: str,
        adjust_params: dict[str, Any] | None = None,
    ) -> None:
        """Saves the plot generated by the Matplotlib instance.

        Args:
            plt_instance (Any): The Matplotlib instance (e.g., plt or figure).
            filename (str): The name of the file to save the plot.
            adjust_params (Optional[Dict[str, Any]]): Parameters for layout adjustments
                using subplots_adjust.
        """
        output_path = getattr(self, "output_path", "")
        file_path = os.path.join(output_path, filename)

        if adjust_params:
            plt_instance.subplots_adjust(**adjust_params)

        plt_instance.savefig(file_path, dpi=600, bbox_inches="tight")

        self.logger.info(f"Plot saved to {file_path}")
        plt_instance.close()

    def plot_boxplot_chart(
        self,
        data: dict[str, list[float]],
        title: str | None = None,
        x_col: str | None = None,
        y_col: str | None = None,
        filename: str = "boxplot.png",
        box_colors: list[str] | None = None,
    ) -> None:
        """Generates a generic boxplot comparing multiple series.

        Args:
            data (Dict[str, List[float]]): A dictionary mapping series names to lists of numbers.
            title (Optional[str]): The title of the plot.
            x_col (str): Column name for the x-axis (numerical values).
            y_col (str): Column name for the y-axis (categories).
            filename (str): The file name to save the plot.
            box_colors (Optional[List[str]]): List of colors to apply to each box.
        """
        self.logger.info("Generating generic boxplot.")

        series_labels = list(data.keys())
        series_data = list(data.values())

        fig, ax = plt.subplots(figsize=(10, 6))
        box = ax.boxplot(
            series_data,
            labels=series_labels,
            patch_artist=True,
            boxprops=dict(color="black"),
            medianprops=dict(color="orange", linewidth=2),
            whiskerprops=dict(color="black", linestyle="--"),
            capprops=dict(color="black"),
        )

        ax.set_title(title if title else "Boxplot", fontsize=16, fontweight="bold")
        ax.set_ylabel(y_col if y_col else "Values", fontsize=12)
        ax.set_xlabel(x_col if x_col else "Series", fontsize=12)
        ax.grid(True, linestyle="--", alpha=0.6)

        if box_colors:
            for patch, color in zip(box["boxes"], box_colors * len(series_labels)):
                patch.set_facecolor(color)

        self._save_plot(plt, filename)

    def plot_horizontal_bar_chart(
        self,
        df: pd.DataFrame,
        x_col: str,
        y_col: str,
        title: str | None = None,
        filename: str = "horizontal_bar_chart.png",
        group_col: str | None = None,
        group_colors: dict[Any, str] | None = None,
    ) -> None:
        """Generates a generic horizontal bar chart from a DataFrame.

        Args:
            df (pd.DataFrame): DataFrame containing the data to plot.
            x_col (str): Column name for the x-axis (numerical values).
            y_col (str): Column name for the y-axis (categories).
            title (Optional[str]): The title of the plot.
            filename (str): The file name to save the plot.
            group_col (Optional[str]): Name of the column that defines group membership.
            group_colors (Optional[Dict[Any, str]]): Mapping from group value to color.
        """
        self.logger.info("Generating generic horizontal bar chart.")

        df_sorted = df.sort_values(by=x_col, ascending=True)

        if group_col is not None:
            if group_colors is None:
                unique_groups = df_sorted[group_col].unique()
                cmap = plt.get_cmap("tab10")
                group_colors = {group: cmap(i % cmap.N) for i, group in enumerate(unique_groups)}
            colors = [group_colors.get(val, "skyblue") for val in df_sorted[group_col]]
        else:
            colors = "skyblue"

        plt.figure(figsize=(10, 6))
        plt.barh(df_sorted[y_col], df_sorted[x_col], color=colors)
        plt.xlabel(x_col)
        plt.ylabel(y_col)
        plt.title(title)
        plt.grid(axis="x", linestyle="--", alpha=0.7)
        self._save_plot(plt, filename)

    def plot_grouped_bar_chart(
        self,
        df: pd.DataFrame,
        x_col: str,
        series: list[str],
        series_labels: list[str] | None = None,
        colors: list[str] | None = None,
        title: str | None = None,
        xlabel: str | None = None,
        ylabel: str | None = None,
        filename: str = "grouped_bar_chart.png",
        bar_width: float = 0.2,
    ) -> None:
        """Generates a generic grouped vertical bar chart from a DataFrame.

        Args:
            df (pd.DataFrame): DataFrame containing the data to plot.
            x_col (str): The column name for the x-axis (categories).
            series (List[str]): List of column names in df representing different series to plot as
                                bars.
            series_labels (Optional[List[str]]): Optional list of labels for each series.
                                                 If not provided, series names are used.
            colors (Optional[List[str]]): Optional list of colors for the bars. If not provided,
                                          defaults are used.
            title (Optional[str]): Title of the chart.
            xlabel (Optional[str]): Label for the x-axis.
            ylabel (Optional[str]): Label for the y-axis.
            filename (str): File name to save the chart.
            bar_width (float): Width of each bar.
        """
        self.logger.info("Generating generic grouped vertical bar chart.")
        # Get the x-axis categories.
        categories = df[x_col].tolist()
        x = np.arange(len(categories))
        n_series = len(series)

        # Use provided series labels or default to series names.
        if series_labels is None:
            series_labels = series

        # Generate default colors if not provided.
        if colors is None:
            cmap = plt.get_cmap("tab10")
            colors = [cmap(i % cmap.N) for i in range(n_series)]

        fig, ax = plt.subplots(figsize=(10, 6))

        # Calculate offsets so that the groups of bars are centered.
        for i, col in enumerate(series):
            offset = -((n_series - 1) / 2) * bar_width + i * bar_width
            ax.bar(
                x + offset,
                df[col],
                width=bar_width,
                label=series_labels[i],
                color=colors[i],
            )

        ax.set_xlabel(xlabel if xlabel else x_col, fontsize=12)
        ax.set_ylabel(ylabel if ylabel else "Values", fontsize=12)
        ax.set_title(title if title else "Grouped Bar Chart", fontsize=16, weight="bold")
        ax.set_xticks(x)
        ax.set_xticklabels(categories, fontsize=10)
        ax.legend()
        ax.grid(True, axis="y", linestyle="--", alpha=0.6)

        self._save_plot(plt, filename)

    def _generate_acronym(self, label: str) -> str:
        """Generates an acronym from a label. Takes the first letter of each word up to 3 characters."""
        words = label.split()
        acronym = "".join([w[0].upper() for w in words])[:3]  # Limit to 3 characters
        return acronym

    def plot_radar_chart(
        self,
        labels: list[str],
        data: dict[str, list[float]],
        title: str | None = None,
        filename: str = "radar_chart.png",
    ) -> None:
        """Generates a radar chart with label acronyms and a legend mapping to full names.

        Args:
            labels (List[str]): The labels for each axis.
            data (Dict[str, List[float]]): A dictionary mapping series names to lists of values.
                Each list must have the same length as `labels`.
            title (Optional[str]): The title of the radar chart.
            filename (str): The file name to save the plot.
        """
        self.logger.info("Generating radar chart with improved legend positioning.")

        num_vars = len(labels)
        angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()
        angles += angles[:1]

        label_map = {label: self._generate_acronym(label) for label in labels}
        short_labels = [label_map[label] for label in labels]

        fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))
        max_value = 0

        for series_name, values in data.items():
            if not values:
                raise ValueError("Each series in data must have at least one set of values.")

            main_values = values + values[:1]
            max_value = max(max_value, max(main_values))
            ax.plot(angles, main_values, label=series_name, linewidth=2)
            ax.fill(angles, main_values, alpha=0.25)

        ax.set_thetagrids(np.degrees(angles[:-1]), short_labels, fontsize=12, weight="bold")
        ax.set_ylim(0, max_value * 1.1)
        ax.set_title(title, fontsize=14, weight="bold", pad=30, loc="center")

        ax.grid(color="gray", linestyle="--", linewidth=0.5, alpha=0.7)

        # Add legend for series (Individual, Team Average, Historical Avg)
        # Positioned at the bottom center to avoid overlapping with title or side legend
        ax.legend(
            loc="upper center",
            bbox_to_anchor=(0.5, -0.05),
            fontsize=10,
            frameon=True,
            fancybox=True,
            shadow=True,
            ncol=3,
        )

        legend_text = "\n".join([f"{acronym}: {full_label}" for full_label, acronym in label_map.items()])

        max_chars_per_line = max(len(line) for line in legend_text.split("\n"))
        char_width_factor = 0.015
        estimated_width = max_chars_per_line * char_width_factor

        max_legend_width = min(0.15, estimated_width)

        adjusted_right = max(0.45, 1 - max_legend_width)
        fig.subplots_adjust(left=0.15, right=adjusted_right, top=0.85, bottom=0.2)

        plt.figtext(
            1 - max_legend_width / 2,
            0.5,
            legend_text,
            fontsize=10,
            ha="left",
            va="center",
            bbox=dict(boxstyle="round,pad=0.5", fc="w", ec="0.8"),
        )

        self._save_plot(
            plt,
            filename,
        )

    def plot_diverging_bar_chart(
        self,
        labels: list[str],
        values: list[float],
        title: str | None = None,
        filename: str = "diverging_bar_chart.png",
        positive_color: str = "#2ecc71",
        negative_color: str = "#e74c3c",
        neutral_color: str = "#95a5a6",
        xlabel: str = "Gap from Team Average",
        group_labels: list[str] | None = None,
        annotations: list[str] | None = None,
        threshold: float = 0.1,
    ) -> None:
        """Generates a horizontal diverging bar chart with bars extending left/right from zero.

        Args:
            labels: Y-axis labels for each bar.
            values: Numeric values determining bar direction and length.
            title: Chart title.
            filename: Output file name.
            positive_color: Color for bars above threshold.
            negative_color: Color for bars below negative threshold.
            neutral_color: Color for bars within threshold.
            xlabel: Label for the x-axis.
            group_labels: If provided, criterion group name per label for separator lines.
            annotations: If provided, text placed at end of each bar.
            threshold: Absolute value below which bars are colored neutral.
        """
        self.logger.info("Generating diverging bar chart.")

        n = len(labels)
        colors = []
        for v in values:
            if v > threshold:
                colors.append(positive_color)
            elif v < -threshold:
                colors.append(negative_color)
            else:
                colors.append(neutral_color)

        _fig, ax = plt.subplots(figsize=(14, max(8, n * 0.55)))
        y_positions = np.arange(n)

        ax.barh(y_positions, values, color=colors, edgecolor="white", height=0.6)

        # Draw group separators and headers
        if group_labels:
            current_group = None
            for i, grp in enumerate(group_labels):
                if grp != current_group:
                    if current_group is not None:
                        sep_y = i - 0.5
                        ax.axhline(y=sep_y, color="gray", linestyle="--", linewidth=0.8, alpha=0.5)
                    current_group = grp
            # Add group name annotations on the right margin
            current_group = None
            group_positions: list[tuple[str, float, float]] = []
            start_idx = 0
            for i, grp in enumerate(group_labels):
                if grp != current_group:
                    if current_group is not None:
                        group_positions.append((current_group, start_idx, i - 1))
                    current_group = grp
                    start_idx = i
            if current_group is not None:
                group_positions.append((current_group, start_idx, n - 1))

            for grp_name, s, e in group_positions:
                mid_y = (s + e) / 2.0
                ax.annotate(
                    grp_name,
                    xy=(1.02, mid_y),
                    xycoords=("axes fraction", "data"),
                    fontsize=8,
                    fontweight="bold",
                    va="center",
                    ha="left",
                    color="#555555",
                )

        # Annotations at end of bars
        if annotations:
            for i, (val, ann) in enumerate(zip(values, annotations, strict=False)):
                x_offset = 0.02 if val >= 0 else -0.02
                ha = "left" if val >= 0 else "right"
                ax.text(val + x_offset, i, ann, va="center", ha=ha, fontsize=8, color="#333333")

        ax.set_yticks(y_positions)
        ax.set_yticklabels(labels, fontsize=10)
        ax.set_xlabel(xlabel, fontsize=12)
        ax.axvline(x=0, color="black", linewidth=0.8)
        ax.set_title(title or "Diverging Bar Chart", fontsize=14, fontweight="bold")
        ax.grid(axis="x", linestyle="--", alpha=0.4)
        ax.invert_yaxis()

        plt.tight_layout()
        self._save_plot(plt, filename)

    def plot_dumbbell_chart(
        self,
        labels: list[str],
        before_values: list[float],
        after_values: list[float],
        before_label: str = "Previous",
        after_label: str = "Current",
        title: str | None = None,
        filename: str = "dumbbell_chart.png",
        improve_color: str = "#2ecc71",
        decline_color: str = "#e74c3c",
        stable_color: str = "#95a5a6",
        threshold: float = 0.1,
        show_delta: bool = True,
    ) -> None:
        """Generates a horizontal dumbbell (dot) chart for before/after comparison.

        Rows are sorted by delta descending (biggest improvements first â€” strengths-first).

        Args:
            labels: Row labels (criteria or indicators).
            before_values: Values for the previous period.
            after_values: Values for the current period.
            before_label: Legend label for before dots.
            after_label: Legend label for after dots.
            title: Chart title.
            filename: Output file name.
            improve_color: Color for improved rows.
            decline_color: Color for declined rows.
            stable_color: Color for stable rows.
            threshold: Absolute delta below which change is considered stable.
            show_delta: Whether to annotate delta text on each row.
        """
        self.logger.info("Generating dumbbell chart.")

        # Sort by delta descending (strengths first)
        deltas = [a - b for a, b in zip(after_values, before_values, strict=False)]
        sorted_indices = sorted(range(len(deltas)), key=lambda i: deltas[i], reverse=True)

        sorted_labels = [labels[i] for i in sorted_indices]
        sorted_before = [before_values[i] for i in sorted_indices]
        sorted_after = [after_values[i] for i in sorted_indices]
        sorted_deltas = [deltas[i] for i in sorted_indices]

        n = len(sorted_labels)
        _fig, ax = plt.subplots(figsize=(12, max(6, n * 0.7)))
        y_positions = np.arange(n)

        for i in range(n):
            delta = sorted_deltas[i]
            if delta > threshold:
                color = improve_color
            elif delta < -threshold:
                color = decline_color
            else:
                color = stable_color

            # Connecting line
            ax.plot(
                [sorted_before[i], sorted_after[i]],
                [i, i],
                color=color,
                linewidth=2.5,
                zorder=1,
            )
            # Before dot
            ax.scatter(sorted_before[i], i, color=color, s=100, zorder=2, edgecolors="white", linewidths=0.5)
            # After dot
            ax.scatter(sorted_after[i], i, color=color, s=100, zorder=2, marker="D", edgecolors="white", linewidths=0.5)

            # Delta annotation
            if show_delta:
                x_pos = max(sorted_before[i], sorted_after[i]) + 0.15
                if abs(delta) < threshold:
                    delta_text = "="
                else:
                    delta_text = f"{delta:+.2f}"
                ax.text(x_pos, i, delta_text, va="center", ha="left", fontsize=9, fontweight="bold", color=color)

        ax.set_yticks(y_positions)
        ax.set_yticklabels(sorted_labels, fontsize=10)
        ax.set_xlim(0, 5.5)
        ax.set_xlabel("Score", fontsize=12)
        ax.set_title(title or "Dumbbell Chart", fontsize=14, fontweight="bold")
        ax.grid(axis="x", linestyle="--", alpha=0.4)
        ax.invert_yaxis()

        # Legend
        ax.scatter([], [], color="gray", s=80, label=before_label)
        ax.scatter([], [], color="gray", s=80, marker="D", label=after_label)
        ax.legend(loc="lower right", fontsize=10)

        plt.tight_layout()
        self._save_plot(plt, filename)

    def plot_donut_chart(
        self,
        labels: list[str],
        sizes: list[float],
        title: str | None = None,
        filename: str = "donut_chart.png",
        colors: list[str] | None = None,
        center_text: str | None = None,
        annotations: list[str] | None = None,
    ) -> None:
        """Generates a donut (ring) chart with optional center text and annotations.

        Args:
            labels: Wedge labels.
            sizes: Wedge sizes (percentages or proportions).
            title: Chart title.
            filename: Output file name.
            colors: List of colors for wedges. If None, uses a default palette.
            center_text: Text rendered in the center of the donut.
            annotations: Lines of text rendered below the chart as a key-metrics block.
        """
        self.logger.info("Generating donut chart.")

        # Filter out zero-size entries
        filtered = [(lbl, sz) for lbl, sz in zip(labels, sizes, strict=False) if sz > 0]
        if not filtered:
            self.logger.warning("All sizes are zero -- skipping donut chart.")
            return
        f_labels, f_sizes = zip(*filtered, strict=False)

        if colors:
            # Filter colors to match non-zero entries
            f_colors = [colors[i] for i, sz in enumerate(sizes) if sz > 0]
        else:
            cmap = plt.get_cmap("Set2")
            f_colors = [cmap(i % cmap.N) for i in range(len(f_labels))]

        fig, ax = plt.subplots(figsize=(10, 10))

        _wedges, _texts, autotexts = ax.pie(
            f_sizes,
            labels=f_labels,
            autopct="%1.1f%%",
            startangle=140,
            colors=f_colors,
            wedgeprops=dict(width=0.4, edgecolor="white"),
            pctdistance=0.8,
            textprops={"fontsize": 10},
        )

        for at in autotexts:
            at.set_fontsize(9)
            at.set_fontweight("bold")

        if center_text:
            ax.text(0, 0, center_text, ha="center", va="center", fontsize=14, fontweight="bold", color="#333333")

        ax.set_title(title or "Donut Chart", fontsize=14, fontweight="bold", pad=20)

        if annotations:
            annotation_block = "\n".join(annotations)
            fig.text(
                0.5,
                0.02,
                annotation_block,
                ha="center",
                va="bottom",
                fontsize=10,
                family="monospace",
                bbox=dict(boxstyle="round,pad=0.5", fc="#f9f9f9", ec="#cccccc"),
            )

        plt.tight_layout()
        self._save_plot(plt, filename)
